<macros>
    <token name="@VERSION@">0.14.1</token>
    <token name="@GALAXY_VERSION@">galaxy0</token>
    <xml name="requirements">
        <requirements>
            <requirement type="package" version="@VERSION@">salmon</requirement>
        </requirements>
    </xml>
    <xml name="index">
        <!-- Salmon data manager not at 0.14.1 yet.
        https://github.com/galaxyproject/tools-iuc/pull/2189
        <conditional name="preindexed">
            <param name="indexed" type="select" label="Index files">
                <option value="indexed">Use a built-in index</option>
                <option value="history" selected="True">Use one from the history</option>
            </param>
            <when value="indexed">
                <param name="fasta" type="select" label="Select a reference transcriptome" help="If your transcriptome of interest is not listed, contact your Galaxy admin">
                <options from_data_table="data_manager_salmon_index_builder">
                    <filter type="sort_by" column="2"/>
                    <validator type="no_options" message="No indexes are available for the selected input dataset"/>
                </options>
            </param>
            </when>
            <when value="history">
            -->
        <section name="s_index" title="salmon_index" expanded="true">
            <param name="fasta" type="data" format="fasta, fa" label="Transcripts fasta file"/>
            <param name="kmer" type="integer" value="31" label="Kmer length"/>
            <param name="phash" type="boolean" label="Perfect Hash" truevalue="--perfectHash" falsevalue="" help="Build the index using a perfect hash rather than a dense hash.  This will require less memory (especially during quantification), but will take longer to construct"/>
        </section>
            <!--</when>
        </conditional>-->
    </xml>
    <xml name="alevin">
        <conditional name="pairstraight">
            <param name="readselect" label="Single or paired-end reads?" type="select">
                <option value="paired">Paired-end</option>
                <option value="unmated">Single-end</option>
            </param>
            <when value="paired">
                <param name="file1" type="data" format="fastq, fastq.gz, fastqsanger.gz" help="CB+UMI raw sequence file(s)"/>
                <param name="file2" type="data" format="fastq, fastq.gz, fastqsanger.gz" help="Read-sequence file(s)"/>
                <param name="orientation" type="select" label="Relative orientation of reads within a pair">
                        <option value="M">Mates are oriented in the same direction (M = matching)</option>
                        <option value="O">Mates are oriented away from each other (O = outward)</option>
                        <option value="I" selected="True">Mates are oriented toward each other (I = inward)</option>
                </param>
                <param name="strandedness" type="select" label="Specify the strandedness of the reads">
                        <option value="U" selected="True">Not stranded (U)</option>
                        <option value="SF">read comes from the forward strand (SF)</option>
                        <option value="SR">read comes from the reverse strand (SR)</option>
                </param>
            </when>
            <when value="unmated">
                <param name="unmatedreads" type="data" format="fastq, fastq.gz" label="Unmated reads files"/>
                <param name="strandedness" type="select" label="Specify the strandedness of the reads">
                        <option value="U" selected="True">Not stranded (U)</option>
                        <option value="SF">read 1 (or single-end read) comes from the forward strand (SF)</option>
                        <option value="SR">read 1 (or single-end read) comes from the reverse strand (SR)</option>
                </param>
            </when>
        </conditional>
        <param name="protocol" type="select">
            <option value="--dropseq">DropSeq Single Cell protocol</option>
            <option value="--chromium">10x chromium v2 Single Cell protocol</option>
            <option value="--chromiumV3">10x chromium v3 Single Cell protocol</option>
            <option value="--gemcode">Gemcode v1 Single Cell protocol</option>
            <option value="--celseq">CEL-Seq Single Cell protocol</option>
            <option value="--celseq2">CEL-Seq2 Single Cell protocol</option>
        </param>
        <param name="tgmap" type="data" format="tsv, tabular" label="Transcript to gene map file" help="Tsv with no header, containing two columns mapping each transcript present in the reference to the corresponding gene (the first column is a transcript and the second is the corresponding gene)."/>
        <section name="optional" title="Optional commands" expanded="false">
            <param name="whitelist" type="data" format="tsv, tabular" optional="true" label="Whitelist file" help="Explicitly specify whitelist CP for cell detection and CB sequence correction. If not specified, putative CBs generated."/>
            <param name="noDedup" type="boolean" truevalue="Yes" falsevalue="No" checked="false" help="Causes pipeline to only perform CB correction, then maps the read-sequences to the transcriptome generating the interim data-structure of CB-EqClass-UMI-count. Used in parallel with --dumpBarcodeEq or --dumpBfh for the purposes of obtaining raw information or debugging."/>
            <param name="mrna" type="data" format="tsv" optional="true" help="Single column tsv of mitochondrial genes which are to be used as a feature for CB whitelising naive Bayes classification."/>
            <param name="rrna" type="data" format="tsv" optional="true" help="Single column tsv of ribosomal genes which are to be used as a feature for CB whitelising naive Bayes classification."/>
            <param name="dumpBfh" type="boolean" truevalue="Yes" falsevalue="No" checked="false" help="Dumps the full CB-EqClass-UMI-count data-structure for the purposed of allowing raw data analysis and debugging."/>
            <param name="dumpFeatures" type="boolean" truevalue="Yes" falsevalue="No" checked="false" help="Dumps all features used by the CB classification and their counts at each cell level. Generally, this is used for the purposes of debugging."/>
            <param name="dumpUmiGraph" type="boolean" truevalue="Yes" falsevalue="No" checked="false" help="Dump the per-cell level umi graph"/>
            <param name="dumpMtx" type="boolean" truevalue="Yes" falsevalue="No" checked="false" help="Converts the default binary format of alevin for gene-count matrix into a human readable mtx (matrix market exchange) sparse format."/>
            <param name="forceCells" type="integer" optional="true" help="Explicitly specify the number of cells."/>
            <param name="expectCells" type="integer" optional="true" help="define a close upper bound on expected number of cells."/>
            <param name="numCellBootstraps" type="integer" optional="true" help="Performs certain number of bootstrap and generate the mean and variance of the count matrix"/>
            <param name="minScoreFraction" type="float" optional="true" help="This value controls the minimum allowed score for a mapping to be considered valid. It matters only when --validateMappings has been passed to Salmon. The maximum possible score for a fragment is ms = read_len * ma (or ms = (left_read_len + right_read_len) * ma for paired-end reads). The argument to --minScoreFraction determines what fraction of the maximum score s a mapping must achieve to be potentially retained. For a minimum score fraction of f, only mappings with a score less than (f * s) will be kept. Mappings with lower scores will be considered as low-quality, and will be discarded."/>
            <param name="keepCBFraction" type="float" optional="true" help="Fraction of cellular barcodes to keep (Between 0 and 1)."/>
            <param name="lowRegionMinNumBarcodes" type="integer" optional="true" help="Minimum number of cell barcodes to use fo learning low confidence region (defaults to 200)"/>
            <param name="maxNumBarcodes" type="integer" optional="true" help="Maximum allowable limit to process the cell barcodes. Defaults to 100000"/>
        </section>
    </xml>
    <xml name="citations">
        <citations>
            <citation type="doi">10.1186/s13059-019-1670-y</citation>
            <citation type="doi">10.1038/nmeth.4197</citation>
        </citations>
    </xml>
    <token name="@salmonhelp@"><![CDATA[
        Salmon is a lightweight method for quantifying transcript abundance from RNA–seq reads, combining a dual-phase parallel inference algorithm and feature-rich bias models with an ultra-fast read mapping procedure.

        The salmon package contains 4 tools:

            * Index: creates a salmon index

            * Quant: quantifies a sample

            * Alevin: Single-cell analysis

            * Quantmerge: Merges multiple quantifications into a single file

        Galaxy divides these four into two separate toools in the IUC toolshed:

            * Salmon transcripts

            * Alevin
        ]]>
    </token>
    <token name="@alevinhelp@"><![CDATA[
        Alevin is a tool — integrated with the salmon software — that introduces a family of algorithms for quantification and analysis of 3’ tagged-end single-cell sequencing data. Currently alevin supports the following two major droplet based single-cell protocols:

            * Drop-seq

            * 10x-Chromium v1/2/3

        Alevin works under the same indexing scheme (as salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools).

        Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated.

        For further information regarding the tool and its optional parameters, visit the `Alevin <https://salmon.readthedocs.io/en/latest/alevin.html?highlight=alevin>`__ and `Salmon <https://salmon.readthedocs.io/en/latest/index.html>`__ wikis.
        ]]>
    </token>
    <!-- for once data manager is at 0.14.1 -->
    <token name="@indexingfixed@"><![CDATA[
        mkdir ./index
        && mkdir ./output
        #if '${preindexed.indexed}' != "indexed":
            && salmon index -i ./index
                --kmerLen '${preindexed.kmer}'
                --gencode
                --transcripts '${preindexed.fasta}'
            #set $index_path = './index'
        #else:
            echo test
            ##set $index_path = $preindexed.indexed.index.fields.path
        #end if
        ]]>
    </token>
    <token name="@indexing@"><![CDATA[
        mkdir ./index
        && mkdir ./output
        && salmon index -i ./index
            --kmerLen '${s_index.kmer}'
            --gencode
            --transcripts '${s_index.fasta}'
        #set $index_path = './index'
        ]]>
    </token>
    <token name="@alevinrun@"><![CDATA[
        && ln -s '${tgmap}' '$__tool_directory__/'alevinmap.tsv
        #if $pairstraight.readselect == "paired":
            && ln -s '${pairstraight.file1}' '$__tool_directory__/'alevin1.fastq
            && ln -s '${pairstraight.file2}' '$__tool_directory__/'alevin2.fastq
        #else:
            && ln -s '${pairstraight.unmatedreads}' '$__tool_directory__/'alevin3.fastq
        #end if
        && salmon alevin -l
        #if $pairstraight.readselect == "paired":
            ${pairstraight.orientation}${pairstraight.strandedness}
            -i $index_path
            -1 '$__tool_directory__/'alevin1.fastq
            -2 '$__tool_directory__/'alevin2.fastq
        #else:
            ${pairstraight.strandedness}
            -i $index_path
            -r '$__tool_directory__/'alevin3.fastq
        #end if
        -o ./output
        -p "\${GALAXY_SLOTS:-4}"
        '${protocol}'
        --tgMap '$__tool_directory__/'alevinmap.tsv
        #if $whitelist:
            --whitelist '${optional.whitelist}'
        #end if
        #if $optional.numCellBootstraps:
            --numCellBootstraps '${optional.numCellBootstraps}'
        #end if
        #if $optional.forceCells:
            --forceCells '${optional.forceCells}'
        #end if
        #if $optional.expectCells:
            --expectCells '${optional.expectCells}'
        #end if
        #if $optional.mrna:
            --mrna '${optional.mrna}'
        #end if
        #if $optional.rrna:
            --rrna '${optional.rrna}'
        #end if
        #if $optional.keepCBFraction:
            --keepCBFraction '${optional.keepCBFraction}'
        #end if
        #if $optional.dumpBfh:
            --dumpBfh
        #end if
        #if $optional.dumpFeatures:
            --dumpFeatures
        #end if
        #if $optional.dumpUmiGraph:
            --dumpUmiGraph
        #end if
        #if $optional.dumpFeatures:
            --dumpFeatures
        #end if
        #if $optional.dumpMtx:
            --dumpMtx
        #end if
        #if $optional.lowRegionMinNumBarcodes:
            --lowregionMinNumBarcodes '${optional.lowRegionMinNumBarcodes}'
        #end if
        #if $optional.maxNumBarcodes:
            --maxNumBarcodes '${optional.maxNumBarcodes}'
        #end if
        && rm '$__tool_directory__/'alevin*.fastq
        && rm '$__tool_directory__/'alevinmap.tsv
        ]]>
    </token>
</macros>
